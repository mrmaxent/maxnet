---
title: "maxnet with stars"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


### Big idea

Here we show how we might model occurrence data and then predict using [maxnet]( https://CRAN.R-project.org/package=maxnet) in conjunction with R packages [sf](https://CRAN.R-project.org/package=sf) and [stars](https://CRAN.R-project.org/package=stars).  We also use the [geodata](https://CRAN.R-project.org/package=stars) for gathering environmental covariate data.

```{r packages}
suppressPackageStartupMessages({
  library(maxnet)
  library(dplyr)
  library(maxnet)
  library(sf)
  library(stars)
  library(geodata)
  library(dismo)
})
```

### Workflow

This example steps through the process of presence-only modeling using the [maxnet package](https://CRAN.R-project.org/package=maxnet)  It shows how to...

+ obtain the Bradypus observation data from the venerable [dismo package](https://CRAN.R-project.org/package=dismo)

+ use the [geodata package](https://CRAN.R-project.org/package=geodata) to assemble predictor variable data,

+ collect background points within the region occupied by the presence points using [sf package](https://CRAN.R-project.org/package=sf)

+ model and predict using the [maxnet package](https://CRAN.R-project.org/package=maxnet)


### Obtain data

#### Occurrence point data

The presence points are stored within the [dismo package](https://CRAN.R-project.org/package=dismo).  Here's how 
we read them in to a data frame.

```{r read-occurence}
obs <- read.csv(system.file("ex/bradypus.csv", package = "dismo"))
head(obs)
```

Next we convert the data frame to a spatial 'simple-features' object.  It's still a data frame, but the location information is consolidated into a list column with of POINT class and we pick up spatial metadata.

```{r convert-to-spatial}
obs <- sf::st_as_sf(obs, coords = c("lon", "lat"), crs = 4326)
obs
```

#### Environmental Covariates

Next we use the [geodata package](https://CRAN.R-project.org/package=geodata) to gather CMIP environmental data for recent times (1970-2000) as well as for 3 future periods 2021-2040, 2041-2060 and 2061-2080). 

```{r get-cmip}
path <- tempdir()
recent <- geodata::worldclim_global(var="bio", res=10, path = path) |>
  stars::st_as_stars() |>
  split()
names(recent) <- sprintf("bio%0.2i", seq_len(length(names(recent))))
```

Next we'll get the modeled data (for the same variables) for the 2021-2040 and 2041-2060 future periods.

```{r get-cmip-future}
future_2021 <- geodata::cmip6_world(model = "CNRM-CM6-1", 
                              ssp = "585", 
                              res = 10, 
                              time = "2021-2040",
                              var = "bioc",
                              path = path) |>
  stars::st_as_stars(ignore_file = TRUE) |>
  split()

future_2041 <- geodata::cmip6_world(model = "CNRM-CM6-1", 
                              ssp = "585", 
                              res = 10, 
                              time = "2041-2060",
                              var = "bioc",
                              path = path) |>
  stars::st_as_stars(ignore_file = TRUE) |>
  split()

future_2061 <- geodata::cmip6_world(model = "CNRM-CM6-1", 
                              ssp = "585", 
                              res = 10, 
                              time = "2061-2080",
                              var = "bioc",
                              path = path) |>
  stars::st_as_stars(ignore_file = TRUE) |>
  split()
```


### Extract recent climate covariates for observations

Next we extract recent covariates for the observations.  These are briefly described [here](https://www.worldclim.org/data/bioclim.html).

```{r extract}
env_obs <- stars::st_extract(recent, sf::st_coordinates(obs)) |>
  dplyr::as_tibble()
env_obs
```

### Points to characterize the recent background

We'll create a polygon around the observations to limit the range of random background point selection.  Note that we buffer the polygon to include neighboring areas.  Also note that we temporarily transform to a projection with rectilinear units to facilitate buffering.

```{r create-background-polygon}
poly <- obs |>                                # start with obs
  sf::st_combine() |>                         # combine into a single multipoint
  sf::st_convex_hull() |>                     # find convex hull
  sf::st_transform(crs = sf::st_crs(5880)) |> # make planar
  sf::st_buffer(dist = 200000) |>             # buffer by 200000m
  sf::st_transform(crs = sf::st_crs(4326))    # make spherical
```

Now we create a set of sample locations within the enclosing polygon, `poly`.  Immediately we'll extract the recent climatic variables for these background points.

```{r sample-polygon}
N <- 1200
back <- sf::st_sample(poly, N)

env_back <- stars::st_extract(recent, sf::st_coordinates(back)) |>
  dplyr::as_tibble() |>
  na.omit()
env_back
```

Let's see what it looks like; we use the first recent covariate (Mean Annual Temp) as the basemap.  Note that some points are clearly not over land so they won't have values when we extract.  That's one reason we selected a high number of points to characterize the environmental setting - we know we'll have to toss some.

```{r plot-points}
col <- sf.colors(categorical = TRUE)
bb <- sf::st_bbox(poly)
plot(recent[1] |> sf::st_crop(bb), 
     main = "", axes = TRUE, key.pos = NULL, reset = FALSE)
maps::map('world', add = TRUE, lwd = 2)
plot(sf::st_geometry(obs), col = col[4], pch = 16, add = TRUE)
plot(sf::st_geometry(poly), add = TRUE, border = col[5], lwd = 2)
plot(back, add = TRUE, col = col[8], pch = ".")
```

### Model

Now we have enough to build the model. First we create a flag vector that distinguishes between observations (1) and background (0).

```{r model}
pres <- c(rep(1, nrow(env_obs)), rep(0, nrow(env_back)))
model <- maxnet::maxnet(pres,
                    dplyr::bind_rows(env_obs, env_back))
```

### Model Metrics

So what can we know about the model?  We can retrieve a list of data frames, each with a table of responses over the range of variable values.  We select the `cloglog` type which nicewly scales responses into the familiar unity range.

```{r retrieve-response}
resp <- plot(model, type = "cloglog", plot = FALSE)
names(resp)
str(resp[['bio02']])
```

We can plot the variable responses.

```{r plot-response}
plot(model, mar = c(3,3,1,2), type = 'cloglog')
```

### Predicting with rasters ([stars](https://r-spatial.github.io/stars/) class)

Here we predict using rasterized inputs cropped to the region of interest.

```{r predict}
clamp <- TRUE       # see ?predict.maxnet for details
type <- "cloglog"
preds <- c(predict(model, recent |> sf::st_crop(bb), 
                   clamp = clamp, type = type),
           predict(model, future_2021 |> sf::st_crop(bb) , 
                   clamp = clamp, type = type),
           predict(model, future_2041 |> sf::st_crop(bb), 
                   clamp = clamp, type = type),
           predict(model, future_2061 |> sf::st_crop(bb), 
                   clamp = clamp, type = type),
           along = list(time=as.Date(c("2001-01-01", 
                                       "2021-01-01", 
                                       "2041-01-01", 
                                       "2061-01-01"))))
preds
```

And we can show the series with the original observations superimposed.

```{r plot-prediction}
plot(preds,
     main = c("recent", "2021-2040", "2041-2061", "2061-2080"),
     hook = function(){plot(obs, col = "orange", add = TRUE)})
```